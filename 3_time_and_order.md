order
=

분산 시스템은 여러 CPU를 통한 연산을 마치 하나의 기계에서 일어나는 것처럼 보이게 하는 것. 그렇기 때문에 순서의 보장은 중요한 문제이다.

분산 시스템의 가장 흔한 정렬 상태는 부분적 정렬이다. 더 정확히는 local order상태이다. 이런 분산시스템에서의 부분적 정렬 상태를 전체 정렬 상태로 만들 수는 있지만, 비용이 들고 어려운 문제이다.

time
=
시간은 보편적으로 통용되는 개념이다. 타임스탬프로 찍힌 시간은 날짜 등으로 변환될 수 있다. 시간은 정렬의 근거가 된다. 

- 타임 스탬프를 근거로 정렬되지 않은 사건을 정렬할 수 있다
- 특정한 메시지나 순서의 행동을 실시할 수 있다.

뿐만 아니라 시간을 통해 얻은 어플리케이션의 지속시간은 시스템이 단순 지연인지, 어플리케이션 상의 파티션 문제인지를 판단할 수 있는 근거가 된다.

당연히, 분산시스템의 컴포넌트들은 예측 불가능하다. 순서를 부여하는 것은 이런 예측 불가능 한 면을 줄여나가는 과정이다.

하지만 이런 면과 별개로 우리가 분산 시스템을 설계할 때는 강한 가정을 하지는 않는 것이 좋다. 가정이 강하면 취약해진다. 일시적으로 결정을 미룰 수록 분산 시스템의 이점을 얻을 수 있다.

time (global clock)
=
동기적 시스템

전역 시계 가정은 완벽한 정확도를 가지는 전역 시계가 있고 모두가 그 시계를 사용할 수 있다는 가정이다. 사소한 오차를 인지하지 못하는 우리, 즉 일반적으로 우리가 하는 사고라도 볼 수 있다.

전역 시계는 전체 정렬의 근거가 된다.

하지만 이런 가정은 이상적이다. 현실에서는 시공간의 제약에 따라 일정한 정도의 정확성만 보장할 수 있다.

전역 시계 가정을 채택한 예로는 페이스북의 카산드라가 있다. 카산드라는 쓰기 연산의 conflict를 해결하기 위해 타임스탬프를 사용한다.

time (local clock)
=
부분적 동기적 시스템

각각의 기계는 각각의 시계를 가지고 있지만, 전역적인 시계는 없다는 가정이다. 즉, 서로 다른 기계사이의 시간을 비교하는 것은 무의미하다는 가정이다.

이런 가정은 부분적인 정렬이 가능함을 의미한다. 각각의 기계안에서의 정렬은 가능하지만, 기계들 간의 정렬은 (시간 만을 기준으로 삼는다면) 불가능하다는 가정이다.

time (no clock)
=
비동기 시스템

시간 대신 다른 방식을 통해 인과관계를 추론하는 방법. 

vector clock
=
논리적인 시간 순에서는 인과관계가 중요할 뿐, 어떤게 얼마나 빨리 발생했는지는 중요하지 않다. 서로 다른 두 프로세스가 서로 메시지를 주고 받지 않고 묵묵히 자신의 일만을 한다면, 두 프로세스는 상관관계가 없으면 concurrent한 이벤트이다. 이런 이벤트는 동기화의 대상이 아니다. 

Lamport Clock: 시스템이 일하거나, 메시지를 보내면 1 증가, 메시지를 수신하면 최대값으로 갱신.

[참고]
https://kukuta.tistory.com/105

vector clock은 Lamport Clock을 확장한 것이다. 노드(서버)와 count의 쌍을 의미한다.

[참고]
https://darkstart.tistory.com/144

단점으로는 한 노드마다 하나의 entry가 필요하다는 것으로 시스템에 규모가 크면 유지비용이 클 수 있다.

failure detector
=
어플리케이션이 대기에 사용한 시간은 노드가 실패한 건지, 단순한 지연인지를 판단하는 좋은 기준이다.

완전성 
- 강한 완전성: 모든 문제가 발생한 시스템은 결국 모든 올바른 시스템에 의해 탐지된다.
- 약한 완전성: 모든 문제가 발생한 시스템은 결국 몇몇 올바른 시스템에 의해 탐지된다.

정밀성
- 강한 정밀성: 올바른 시스템은 결코 의심받지 않는다.
- 약한 정밀성: 올바른 시스템도 때로 의심받을 수 있다.

완전성은 대체로 정밀성보다 얻기 쉽다. 왜냐하면 약한 완전성을 가진 서비스라도 정확하다면 전파를 통해 강한 완전성으로 전환할 수 있기 때문이다.

하지만 딜레이에 대한 명확한 규정이 없는 경우에, 헛다리를 집지 않는 것은 어렵다. (기껏해야 eventual accurate에 그친다.)

하지만 약한 정밀성을 가진 시스템도 합의 문제를 푸는데 이용될 수 있다.

