single-copy 방식의 강한 보장을 하는 서비스는 비용이 크다. 대신 다른 레플리카들이 분화할 수 있다는 가능성을 열어두고 대신 쓸만한 데이터를 얻는 것에 타협을 할 수 있다. 

eventual-consistency가 바로 이런 아이디어와 관련이 있다.

1. 확률적인 보장을 해주는 궁극적 일관성: 언젠가 충돌을 감지하지만, 반드시 올바른 결과를 반환한다고 보장하지는 않는 방식
2. 강한 보장을 해주는 궁극적 일관성: 언젠가는 반드시 올바를 결과를 반환한다고 보장해주는 방식

Dynamo
=
weak-consistency guarantee를 보장하는 가장 유명한 시스템이다.
Dynamo는 가용성을 일관성보다 중요시한다. single-copy의 보장을 해주지는 않지만, 값을 읽을 때 클라이언트에 반환해주기 전에 레플리카 사이에 다른점을 조정해준다.

충돌 감지와 수정
=
일반적으로 메타데이터를 통해 인과관계를 추론하여 충돌을 감지한다. 앞서 확인한 vector clock이 한 예이다. 

메타데이터가 없다면, 딱히 할 수 있는게 없다. 이런 경우에는 last-writer-wins와 같은 방식을 사용할 수 있다.

레플리카 동기화: gossip and merkle trees
=
가십은 통계적으로 레플리카를 동기화하는 테크닉이다. 확장 가능하고 single point of failure를 가지지 않지만 확률적인 보장만을 해줄 수 있다.

소문이 전파되어나가듯 Broadcast 해주는 마스터가 없이 각 노드가 주기적으로 TCP/UDP 기반으로 메타데이터를 주고받으면서 데이터를 전송한다. 각 노드들은 주기적으로 다른 노드의 Health Check 를 수행하고 통신하므로, 주기적으로 Peer to Peer (P2P) 의 통신으로 전달이 일어나며, 일반적으로 신뢰성은 보장하지 않는다.

[참고]
https://jins-dev.tistory.com/244

레플리카 사이의 동기화 과정에서 정보교환을 효율적으로 하기 위해 merkle tree(해시 트리)를 사용한다.

